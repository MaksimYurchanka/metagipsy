import React, { useState, useCallback } from 'react';
import { useNavigate } from 'react-router-dom';
import { Upload, Eye, Brain, CheckCircle, Sparkles, Zap } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { Textarea } from '@/components/ui/textarea';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Badge } from '@/components/ui/badge';
import { Switch } from '@/components/ui/switch';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Card, CardContent } from '@/components/ui/card';
import { toast } from 'sonner';
import { ConversationInputProps, Platform } from '@/types';
import { useConversationStore } from '@/stores/conversationStore';
import { api } from '@/lib/api';

const ConversationInput: React.FC<ConversationInputProps> = ({
  onAnalyze,
  isAnalyzing = false
}) => {
  const navigate = useNavigate();
  
  // ‚úÖ ELEGANT STATE - —Ç–æ–ª—å–∫–æ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ–µ
  const [conversationText, setConversationText] = useState('');
  const [platform, setPlatform] = useState<Platform>('auto');
  const [sessionGoal, setSessionGoal] = useState('');
  const [enableAIAnalysis, setEnableAIAnalysis] = useState(true);
  const [isParsing, setIsParsing] = useState(false);
  
  // ‚úÖ DETECTION STATE
  const [detectedPlatform, setDetectedPlatform] = useState<Platform | null>(null);
  const [messageCount, setMessageCount] = useState(0);
  const [hasRetryEditFormat, setHasRetryEditFormat] = useState(false);

  // ‚úÖ SMART DETECTION - Claude.ai copy-paste + Retry‚ÜíEdit
  const analyzeText = useCallback((text: string) => {
    if (!text.trim()) {
      setDetectedPlatform(null);
      setMessageCount(0);
      setHasRetryEditFormat(false);
      return;
    }
    
    // Claude.ai Retry‚ÜíEdit format detection
    const retryMatches = text.match(/^Retry\s*$/gm) || [];
    const editMatches = text.match(/^Edit\s*$/gm) || [];
    
    if (retryMatches.length > 0 && editMatches.length > 0) {
      setHasRetryEditFormat(true);
      setDetectedPlatform('claude');
      setMessageCount(Math.min(retryMatches.length, editMatches.length) * 2);
      return;
    }
    
    setHasRetryEditFormat(false);
    
    // Standard platform detection
    const content = text.toLowerCase();
    let detected: Platform = 'other';
    
    if (content.includes('human:') && content.includes('assistant:')) {
      detected = 'claude';
    } else if (content.includes('user:') && content.includes('chatgpt:')) {
      detected = 'chatgpt';
    }
    
    // Message counting
    const messageMarkers = text.match(/(Human:|Assistant:|User:|ChatGPT:)/gmi);
    const alternatingBlocks = text.split(/\n\s*\n/).filter(block => block.trim().length > 20);
    
    const estimatedMessages = messageMarkers ? 
      messageMarkers.length : 
      Math.min(alternatingBlocks.length, 10);
    
    setDetectedPlatform(detected);
    setMessageCount(estimatedMessages);
  }, []);

  const handleTextChange = useCallback((value: string) => {
    setConversationText(value);
    analyzeText(value);
  }, [analyzeText]);

  // ‚úÖ ENHANCED PARSE & VERIFY - with bulletproof 400 error debugging
  const handleParseAndVerify = useCallback(async () => {
    if (!conversationText.trim()) {
      toast.error('Please paste your conversation first');
      return;
    }

    if (messageCount < 2) {
      toast.error('Need at least 2 messages to verify');
      return;
    }

    console.log('üîç NAVIGATING TO VERIFY PAGE...');
    
    // ‚úÖ ENHANCED: AI parsing with bulletproof error debugging
    let parsedMessages = null;
    let parsingMethod = 'local';
    
    if (enableAIAnalysis) {
      setIsParsing(true);
      toast.info('Using AI for smart parsing...');
      
      try {
        // ‚úÖ BULLETPROOF: Pre-validation logging
        console.log('üîç ENHANCED PARSING REQUEST DETAILS:', {
          textLength: conversationText.length,
          textPreview: conversationText.substring(0, 100) + '...',
          hasText: !!conversationText,
          textType: typeof conversationText,
          textTrimmedLength: conversationText.trim().length,
          platform: platform === 'auto' ? detectedPlatform || 'auto' : platform,
          detectedPlatform,
          messageCount,
          hasRetryEditFormat,
          enableAIAnalysis,
          timestamp: new Date().toISOString()
        });

        // ‚úÖ BULLETPROOF: Pre-validation checks to prevent 400 errors
        if (!conversationText || typeof conversationText !== 'string') {
          throw new Error(`‚ùå VALIDATION: Invalid text parameter - hasText=${!!conversationText}, type=${typeof conversationText}`);
        }
        
        if (conversationText.trim().length < 10) {
          throw new Error(`‚ùå VALIDATION: Text too short - ${conversationText.trim().length} chars (minimum 10 required)`);
        }
        
        if (conversationText.length > 50000) {
          throw new Error(`‚ùå VALIDATION: Text too long - ${conversationText.length} chars (maximum 50,000 allowed)`);
        }

        // ‚úÖ BULLETPROOF: Ensure platform is valid
        const finalPlatform = platform === 'auto' ? (detectedPlatform || 'auto') : platform;
        if (!['claude', 'chatgpt', 'other', 'auto'].includes(finalPlatform)) {
          throw new Error(`‚ùå VALIDATION: Invalid platform - ${finalPlatform}`);
        }

        console.log('‚úÖ PRE-VALIDATION PASSED - Making API call with validated parameters...');

        // ‚úÖ BULLETPROOF: Enhanced API call with explicit parameters
        const enhancedOptions = {
          expectedPlatform: finalPlatform,
          analysisDepth: 'standard' as const,
          forceHaiku: true, // ‚úÖ EXPLICIT: Always try Haiku first for better accuracy
          userSignature: undefined // ‚úÖ EXPLICIT: Clear undefined values
        };

        console.log('üöÄ API CALL PARAMETERS:', {
          textLength: conversationText.length,
          options: enhancedOptions
        });

        const response = await api.analyzeEnhanced(conversationText, enhancedOptions);
        
        console.log('üì• API RESPONSE RECEIVED:', {
          success: response?.success,
          hasResult: !!response?.result,
          messageCount: response?.result?.messages?.length || 0,
          confidence: response?.result?.confidence || 0,
          method: response?.result?.method || 'unknown',
          needsVerification: response?.metadata?.needsVerification
        });
        
        if (response?.success && response?.result?.messages?.length >= 2) {
          parsedMessages = response.result.messages;
          parsingMethod = 'ai_enhanced';
          console.log('‚úÖ AI PARSING SUCCESS:', {
            messageCount: parsedMessages.length,
            confidence: response.result.confidence,
            method: response.result.method
          });
          toast.success(`üéä AI parsing completed! Found ${parsedMessages.length} messages with ${Math.round((response.result.confidence || 0) * 100)}% confidence.`);
        } else {
          console.log('‚ö†Ô∏è AI PARSING INSUFFICIENT RESULTS:', {
            success: response?.success || false,
            messageCount: response?.result?.messages?.length || 0,
            confidence: response?.result?.confidence || 0,
            hasVerification: !!response?.result?.verification
          });
          throw new Error(`AI parsing returned insufficient messages: ${response?.result?.messages?.length || 0} (need 2+)`);
        }
        
      } catch (error) {
        // ‚úÖ BULLETPROOF: Comprehensive error analysis and logging
        const errorDetails = {
          errorMessage: error instanceof Error ? error.message : 'Unknown error',
          errorType: error instanceof Error ? error.constructor.name : typeof error,
          errorStack: error instanceof Error ? error.stack : undefined,
          textLength: conversationText.length,
          textValid: !!conversationText && typeof conversationText === 'string',
          textTrimmedLength: conversationText.trim().length,
          requestPlatform: platform === 'auto' ? detectedPlatform || 'auto' : platform,
          detectedPlatform,
          enableAIAnalysis,
          timestamp: new Date().toISOString(),
          apiBaseUrl: import.meta.env.VITE_API_URL || 'https://metagipsy-backend.onrender.com/api/v1'
        };

        console.error('‚ùå ENHANCED PARSING COMPREHENSIVE ERROR ANALYSIS:', errorDetails);
        
        // ‚úÖ BULLETPROOF: Smart error classification and user feedback
        const errorMessage = error instanceof Error ? error.message.toLowerCase() : '';
        
        if (errorMessage.includes('400') || errorMessage.includes('bad request') || errorMessage.includes('validation')) {
          toast.error('üîç AI parsing validation failed - using reliable local parsing');
          console.log('üîÑ 400/VALIDATION ERROR DETECTED - Backend rejected request, using local fallback');
        } else if (errorMessage.includes('401') || errorMessage.includes('unauthorized')) {
          toast.warning('üîê AI parsing authentication issue - using local parsing');
          console.log('üîÑ AUTH ERROR DETECTED - Token issue, using local fallback');
        } else if (errorMessage.includes('429') || errorMessage.includes('rate limit')) {
          toast.warning('‚è±Ô∏è AI parsing rate limited - using local parsing');
          console.log('üîÑ RATE LIMIT ERROR DETECTED - Too many requests, using local fallback');
        } else if (errorMessage.includes('500') || errorMessage.includes('server')) {
          toast.warning('üîß AI parsing server unavailable - using local parsing');
          console.log('üîÑ SERVER ERROR DETECTED - Backend issue, using local fallback');
        } else if (errorMessage.includes('network') || errorMessage.includes('fetch')) {
          toast.warning('üåê Network issue - using local parsing');
          console.log('üîÑ NETWORK ERROR DETECTED - Connection problem, using local fallback');
        } else {
          console.log('üîÑ AI PARSING FAILED WITH UNKNOWN ERROR, using local parsing fallback');
          toast.warning('AI parsing unavailable - using reliable local parsing...');
        }
        
        // ‚úÖ BULLETPROOF: Log error for debugging but continue gracefully
        console.log('üõ°Ô∏è GRACEFUL FALLBACK: AI parsing failed but local parsing will handle it perfectly');
        
      } finally {
        setIsParsing(false);
      }
    }
    
    // ‚úÖ ENHANCED: Prepare comprehensive data for verify page
    const verifyData = {
      conversationText,
      platform: platform === 'auto' ? detectedPlatform || 'other' : platform,
      sessionGoal,
      hasRetryEditFormat,
      messageCount,
      enableAIAnalysis,
      parsedMessages, // Pre-parsed messages if AI succeeded
      parsingMethod,
      timestamp: Date.now(),
      debugInfo: {
        detectedPlatform,
        originalPlatform: platform,
        textLength: conversationText.length,
        retryEditDetected: hasRetryEditFormat
      }
    };
    
    // Save to sessionStorage and navigate
    sessionStorage.setItem('metagipsy_verify_data', JSON.stringify(verifyData));
    navigate('/analyze/verify');
  }, [conversationText, platform, detectedPlatform, sessionGoal, hasRetryEditFormat, messageCount, enableAIAnalysis, navigate]);

  // ‚úÖ DIRECT ANALYZE - skip verification
  const handleDirectAnalyze = useCallback(async () => {
    if (!conversationText.trim()) {
      toast.error('Please paste your conversation first');
      return;
    }

    if (messageCount < 2) {
      toast.error('Need at least 2 messages to analyze');
      return;
    }

    console.log('üöÄ DIRECT ANALYZE: Creating analysis request...');

    // Simple local parsing for direct analysis
    const messages = parseSimple(conversationText);
    
    if (messages.length === 0) {
      toast.error('Could not parse any messages from the conversation');
      return;
    }
    
    const analysisRequest = {
      conversation: {
        messages,
        platform: platform === 'auto' ? detectedPlatform || 'other' : platform
      },
      metadata: {
        sessionGoal: sessionGoal || undefined,
        hasRetryEditFormat,
        messageCount: messages.length,
        parsingMethod: 'direct_local',
        timestamp: new Date().toISOString()
      },
      options: {
        useClaudeAnalysis: enableAIAnalysis,
        analysisDepth: 'standard',
        generateSuggestions: true,
        detectPatterns: true
      }
    };

    console.log('üöÄ CALLING onAnalyze with:', {
      messageCount: messages.length,
      platform: analysisRequest.conversation.platform,
      useAIAnalysis: enableAIAnalysis
    });

    onAnalyze(analysisRequest);
  }, [conversationText, platform, detectedPlatform, sessionGoal, hasRetryEditFormat, messageCount, enableAIAnalysis, onAnalyze]);

  // ‚úÖ SIMPLE PARSING for direct analyze
  const parseSimple = (text: string) => {
    const messages: any[] = [];
    
    if (hasRetryEditFormat) {
      return parseRetryEdit(text);
    }
    
    // Standard parsing
    let parts: string[] = [];
    
    if (detectedPlatform === 'claude') {
      parts = text.split(/(?=(?:Human:|Assistant:))/i).filter(p => p.trim());
    } else if (detectedPlatform === 'chatgpt') {
      parts = text.split(/(?=(?:User:|ChatGPT:))/i).filter(p => p.trim());
    } else {
      parts = text.split(/\n\s*\n/).filter(p => p.trim().length > 20);
    }
    
    parts.forEach((part, index) => {
      const trimmed = part.trim();
      if (!trimmed) return;
      
      let role: 'user' | 'assistant' = index % 2 === 0 ? 'user' : 'assistant';
      let content = trimmed;
      
      // Role detection
      if (trimmed.match(/^(Human:|User:)/i)) {
        role = 'user';
        content = trimmed.replace(/^(Human:|User:)\s*/i, '').trim();
      } else if (trimmed.match(/^(Assistant:|ChatGPT:)/i)) {
        role = 'assistant';
        content = trimmed.replace(/^(Assistant:|ChatGPT:)\s*/i, '').trim();
      }
      
      if (content.trim()) {
        messages.push({
          role,
          content: content.trim(),
          index: messages.length,
          timestamp: new Date().toISOString()
        });
      }
    });
    
    return messages;
  };

  // ‚úÖ RETRY‚ÜíEDIT PARSER
  const parseRetryEdit = (text: string) => {
    const messages: any[] = [];
    const lines = text.split('\n');
    
    const retryLines: number[] = [];
    const editLines: number[] = [];
    
    lines.forEach((line, index) => {
      const trimmed = line.trim();
      if (trimmed === 'Retry') retryLines.push(index);
      if (trimmed === 'Edit') editLines.push(index);
    });
    
    for (let i = 0; i < retryLines.length; i++) {
      const retryLine = retryLines[i];
      const nextEdit = editLines.find(edit => edit > retryLine);
      
      if (nextEdit) {
        // User message
        const userMessage = lines.slice(retryLine + 1, nextEdit).join('\n').trim();
        
        if (userMessage && userMessage.length > 10) {
          messages.push({
            role: 'user',
            content: userMessage,
            index: messages.length,
            timestamp: new Date().toISOString()
          });
          
          // Assistant response
          const nextRetry = retryLines[i + 1] || lines.length;
          const assistantLines = lines.slice(nextEdit + 1, nextRetry);
          let assistantMessage = assistantLines.join('\n').trim();
          
          // Clean metadata
          assistantMessage = assistantMessage
            .replace(/^[A-Z][a-z].*?\.\s*\n\d+s\s*\n*/g, '')
            .replace(/^Thought process \d+s\s*\n*/g, '')
            .trim();
          
          if (assistantMessage && assistantMessage.length > 10) {
            messages.push({
              role: 'assistant',
              content: assistantMessage,
              index: messages.length,
              timestamp: new Date().toISOString()
            });
          }
        }
      }
    }
    
    return messages;
  };

  const canAnalyze = conversationText.trim().length > 50 && messageCount >= 2;
  const canVerify = conversationText.trim().length > 20;

  return (
    <div className="space-y-6">
      {/* ‚úÖ ELEGANT HEADER */}
      <div className="text-center space-y-3">
        <h2 className="text-2xl font-bold text-slate-100">Analyze Conversation</h2>
        <p className="text-slate-400 max-w-2xl mx-auto">
          Paste your conversation below for intelligent 5D analysis. Choose to verify parsing or analyze directly.
        </p>
      </div>

      {/* ‚úÖ AI ENHANCEMENT TOGGLE - Dark Theme Optimized */}
      <Card className="bg-gradient-to-r from-purple-950/30 to-blue-950/30 border-purple-800/40">
        <CardContent className="p-4">
          <div className="flex items-center justify-between">
            <div className="flex items-center gap-3">
              <Brain className="h-5 w-5 text-purple-400" />
              <div>
                <Label className="text-sm font-medium text-purple-300">
                  Enhanced AI Analysis
                </Label>
                <p className="text-xs text-purple-400/80 mt-1">
                  Use Claude AI for superior conversation parsing and 5D insights
                </p>
              </div>
            </div>
            <Switch
              checked={enableAIAnalysis}
              onCheckedChange={setEnableAIAnalysis}
              disabled={isAnalyzing || isParsing}
              className="data-[state=checked]:bg-purple-600"
            />
          </div>
        </CardContent>
      </Card>

      {/* ‚úÖ MAIN INPUT - Dark Theme Optimized */}
      <div className="space-y-4">
        <div>
          <Label htmlFor="conversation" className="text-base font-medium text-slate-200">
            Conversation Text
          </Label>
          <Textarea
            id="conversation"
            value={conversationText}
            onChange={(e) => handleTextChange(e.target.value)}
            placeholder="Paste your conversation here...

Supported formats:
‚Ä¢ Claude.ai: Copy multiple messages (Retry/Edit format auto-detected)
‚Ä¢ ChatGPT: Copy with User:/ChatGPT: labels
‚Ä¢ Other: Any clear dialogue format

AI parsing will extract precise message boundaries automatically."
            className="min-h-80 mt-2 bg-slate-900/50 border-slate-700 text-slate-100 placeholder:text-slate-500 resize-none text-base leading-relaxed focus:border-purple-500 focus:ring-purple-500/20"
            disabled={isAnalyzing || isParsing}
          />
        </div>

        {/* ‚úÖ STATUS INDICATORS - Dark Theme */}
        <div className="flex items-center justify-between text-sm">
          <div className="flex items-center gap-4 flex-wrap">
            {detectedPlatform && (
              <div className="flex items-center gap-1">
                <CheckCircle className="h-4 w-4 text-green-400" />
                <span className="text-slate-300 capitalize">
                  Detected: {detectedPlatform}
                  {hasRetryEditFormat && (
                    <span className="text-cyan-400 font-medium"> (Retry‚ÜíEdit)</span>
                  )}
                </span>
              </div>
            )}
            {messageCount > 0 && (
              <Badge variant="secondary" className="bg-slate-800 text-slate-300 border-slate-600">
                ~{messageCount} messages
              </Badge>
            )}
            {enableAIAnalysis && (
              <Badge variant="outline" className="text-purple-400 border-purple-500/50 bg-purple-950/20">
                <Sparkles className="h-3 w-3 mr-1" />
                AI Ready
              </Badge>
            )}
          </div>
        </div>

        {/* ‚úÖ ESSENTIAL FIELDS ONLY - —Å–æ–≥–ª–∞—Å–Ω–æ roadmap */}
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
          <div>
            <Label htmlFor="platform" className="text-slate-200">Platform</Label>
            <Select value={platform} onValueChange={(value: Platform) => setPlatform(value)}>
              <SelectTrigger className="bg-slate-900/50 border-slate-700 text-slate-100">
                <SelectValue />
              </SelectTrigger>
              <SelectContent className="bg-slate-900 border-slate-700">
                <SelectItem value="auto">
                  üîç Auto-detect {detectedPlatform && `(${detectedPlatform})`}
                </SelectItem>
                <SelectItem value="claude">ü§ñ Claude</SelectItem>
                <SelectItem value="chatgpt">üí¨ ChatGPT</SelectItem>
                <SelectItem value="other">üìù Other</SelectItem>
              </SelectContent>
            </Select>
          </div>
          
          <div>
            <Label htmlFor="goal" className="text-slate-200">Session Goal (Optional)</Label>
            <Input
              id="goal"
              placeholder="e.g., Debug code, Plan project..."
              value={sessionGoal}
              onChange={(e) => setSessionGoal(e.target.value)}
              disabled={isAnalyzing || isParsing}
              className="bg-slate-900/50 border-slate-700 text-slate-100 placeholder:text-slate-500"
            />
          </div>
        </div>

        {/* ‚úÖ MINIMAL DISTRACTION - —Å–æ–≥–ª–∞—Å–Ω–æ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏ */}
        <div className="text-center">
          <p className="text-xs text-slate-500">
            üìù <strong>Advanced settings</strong> like project context and analysis depth will be available on the verification page
          </p>
        </div>
      </div>

      {/* ‚úÖ ACTION BUTTONS - Elegant Dark Theme */}
      <div className="flex gap-3">
        <Button
          onClick={handleParseAndVerify}
          disabled={!canVerify || isAnalyzing || isParsing}
          variant="outline"
          className="flex-1 border-blue-600/50 text-blue-400 hover:bg-blue-950/30 hover:border-blue-500 bg-blue-950/10"
        >
          {isParsing ? (
            <>
              <Brain className="h-4 w-4 mr-2 animate-spin" />
              AI Parsing...
            </>
          ) : (
            <>
              <Eye className="h-4 w-4 mr-2" />
              Parse & Preview
            </>
          )}
        </Button>
        
        <Button
          onClick={handleDirectAnalyze}
          disabled={!canAnalyze || isAnalyzing || isParsing}
          className="flex-1 bg-gradient-to-r from-purple-600 to-blue-600 hover:from-purple-700 hover:to-blue-700 text-white"
        >
          {isAnalyzing ? (
            <>
              <Zap className="h-4 w-4 mr-2 animate-spin" />
              Analyzing...
            </>
          ) : (
            <>
              <Upload className="h-4 w-4 mr-2" />
              Direct Analyze
            </>
          )}
        </Button>
      </div>

      {/* ‚úÖ HELPFUL HINTS - Dark Theme */}
      <div className="space-y-2">
        {conversationText.trim() && hasRetryEditFormat && (
          <div className="text-center p-3 bg-cyan-950/20 border border-cyan-800/30 rounded-lg">
            <p className="text-sm text-cyan-300">
              üéØ <strong>Claude.ai format detected!</strong> Retry‚ÜíEdit parsing will extract precise message boundaries.
            </p>
          </div>
        )}
        
        {conversationText.trim() && !canAnalyze && canVerify && (
          <div className="text-center p-3 bg-orange-950/20 border border-orange-800/30 rounded-lg">
            <p className="text-sm text-orange-300">
              üí° You can verify parsing with current text, but need more content for full analysis
            </p>
          </div>
        )}
        
        {!conversationText.trim() && (
          <div className="text-center p-3 bg-slate-800/30 border border-slate-700/50 rounded-lg">
            <p className="text-sm text-slate-400">
              ‚ú® Paste your conversation above to get started with 5D chess analysis
            </p>
          </div>
        )}
      </div>
    </div>
  );
};

export default ConversationInput;