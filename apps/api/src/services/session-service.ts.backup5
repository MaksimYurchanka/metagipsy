import { prisma } from '../lib/prisma';
import { redis } from '../lib/redis';
import { logger } from '../lib/logger';
import { SessionSummary, SessionMetadata, AnalysisPattern, Platform } from '../types';

export class SessionService {
  /**
   * Helper method to normalize platform values to match Prisma enum
   */
  private normalizePlatform(platform?: string): Platform {
    if (!platform) return 'OTHER';
    
    const platformMap: Record<string, Platform> = {
      // Handle lowercase input (from frontend/parser)
      'claude': 'CLAUDE',
      'chatgpt': 'CHATGPT', 
      'other': 'OTHER',
      'auto': 'AUTO',
      // Handle uppercase input (already correct)
      'CLAUDE': 'CLAUDE',
      'CHATGPT': 'CHATGPT',
      'OTHER': 'OTHER',
      'AUTO': 'AUTO'
    };
    
    return platformMap[platform.toLowerCase()] || 'OTHER';
  }

  async createSession(userId: string, userEmail: string, metadata: SessionMetadata): Promise<string> {
    try {
      // ‚úÖ –ö–†–ò–¢–ò–ß–ï–°–ö–û–ï –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: Auto-create user if not exists
      console.log('üë§ ENSURING USER EXISTS:', userId, userEmail);
      
      try {
        await prisma.user.upsert({
          where: { id: userId },
          update: {
            // –û–±–Ω–æ–≤–ª—è–µ–º email –µ—Å–ª–∏ –∏–∑–º–µ–Ω–∏–ª—Å—è
            email: userEmail || 'unknown@example.com',
            updatedAt: new Date()
          },
          create: {
            id: userId,
            email: userEmail || 'unknown@example.com',
            name: userEmail?.split('@')[0] || 'Anonymous User',
            tier: 'FREE'
          }
        });
        
        console.log('‚úÖ USER ENSURED:', userId);
      } catch (userError) {
        console.error('‚ùå User upsert failed:', userError);
        logger.error('User upsert failed', { 
          error: userError, 
          userId, 
          userEmail 
        });
        // –ü—Ä–æ–¥–æ–ª–∂–∞–µ–º –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ - –≤–æ–∑–º–æ–∂–Ω–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
      }

      // –¢–µ–ø–µ—Ä—å —Å–æ–∑–¥–∞–µ–º —Å–µ—Å—Å–∏—é (foreign key constraint –±—É–¥–µ—Ç –≤—ã–ø–æ–ª–Ω–µ–Ω)
      const session = await prisma.session.create({
        data: {
          userId,
          title: metadata.title || `${metadata.platform || 'Analysis'} - ${new Date().toLocaleDateString()}`,
          platform: this.normalizePlatform(metadata.platform),
          
          // ‚úÖ –ù–û–í–û–ï: –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω—ã—Ö –ø–æ–ª–µ–π
          messageCount: metadata.messageCount || 0,
          overallScore: metadata.overallScore || 0,
          strategicAvg: metadata.dimensionAverages?.strategic || 0,
          tacticalAvg: metadata.dimensionAverages?.tactical || 0,
          cognitiveAvg: metadata.dimensionAverages?.cognitive || 0,
          innovationAvg: metadata.dimensionAverages?.innovation || 0,
          trend: metadata.trend || 'stable',
          
          // –î–µ—Ç–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –≤ metadata JSON
          metadata: {
            ...metadata,
            createdAt: new Date().toISOString()
          } as any
        }
      });

      console.log('‚úÖ SESSION CREATED:', session.id);
      logger.info('Session created successfully', { 
        sessionId: session.id, 
        userId,
        userEmail 
      });
      
      return session.id;
    } catch (error) {
      console.error('‚ùå SESSION CREATION FAILED:', error);
      logger.error('Failed to create session', { 
        error, 
        userId, 
        userEmail,
        metadata: metadata.title 
      });
      
      // ‚úÖ –£–õ–£–ß–®–ï–ù–ù–ê–Ø –î–ò–ê–ì–ù–û–°–¢–ò–ö–ê –û–®–ò–ë–û–ö —Å –ø—Ä–∞–≤–∏–ª—å–Ω–æ–π —Ç–∏–ø–∏–∑–∞—Ü–∏–µ–π
      const errorMessage = error instanceof Error ? error.message : String(error);
      const errorCode = (error as any)?.code;
      
      if (errorMessage.includes('Foreign key constraint')) {
        throw new Error('User synchronization failed. Please refresh and try again.');
      } else if (errorCode === 'P2002') {
        throw new Error('Session already exists');
      } else {
        throw new Error('Failed to create session');
      }
    }
  }

  async updateSession(
    userId: string,
    sessionId: string, 
    summary: SessionSummary
  ): Promise<void> {
    try {
      // ‚úÖ CRITICAL FIX: –ü—Ä–∞–≤–∏–ª—å–Ω–æ–µ —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞ –±–µ–∑ 'as any'
      const updatedData = {
        // –ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω—ã–µ –ø–æ–ª—è –¥–ª—è –±—ã—Å—Ç—Ä—ã—Ö –∑–∞–ø—Ä–æ—Å–æ–≤
        messageCount: summary.messageCount,
        overallScore: summary.overallScore,
        strategicAvg: summary.dimensionAverages.strategic,
        tacticalAvg: summary.dimensionAverages.tactical,
        cognitiveAvg: summary.dimensionAverages.cognitive,
        innovationAvg: summary.dimensionAverages.innovation,
        bestScore: summary.bestScore,
        worstScore: summary.worstScore,
        trend: summary.trend,
        
        // ‚úÖ CRITICAL FIX: –ü—Ä–∞–≤–∏–ª—å–Ω–æ–µ —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞
        status: 'COMPLETED' as const, // Using const assertion instead of 'as any'
        
        // –î–µ—Ç–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –≤ metadata
        metadata: {
          messageCount: summary.messageCount,
          overallScore: summary.overallScore,
          bestScore: summary.bestScore,
          worstScore: summary.worstScore,
          trend: summary.trend,
          dimensionAverages: summary.dimensionAverages,
          patterns: summary.patterns,
          insights: summary.insights,
          completedAt: new Date().toISOString(),
          updatedAt: new Date().toISOString()
        } as any
      };

      const updatedSession = await prisma.session.update({
        where: { 
          id: sessionId,
          userId // Ensure user owns the session
        },
        data: updatedData
      });

      // ‚úÖ ENHANCED LOGGING: Log status change for debugging
      console.log('‚úÖ SESSION STATUS UPDATED:', {
        sessionId,
        userId,
        status: updatedSession.status,
        messageCount: updatedSession.messageCount,
        overallScore: updatedSession.overallScore
      });

      // Cache session summary for quick access
      await redis.setex(
        `session:${sessionId}:summary`,
        3600, // 1 hour
        JSON.stringify(summary)
      );

      logger.info('Session updated', { sessionId, userId, status: updatedSession.status });
    } catch (error) {
      console.error('‚ùå SESSION UPDATE FAILED:', {
        error: error instanceof Error ? error.message : String(error),
        sessionId,
        userId,
        summaryMessageCount: summary.messageCount,
        summaryScore: summary.overallScore
      });
      
      logger.error('Failed to update session', { error, sessionId, userId });
      throw new Error('Failed to update session');
    }
  }

  // ‚úÖ –ù–û–í–´–ô –ú–ï–¢–û–î: –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∑–∞–≥–æ–ª–æ–≤–∫–∞ —Å–µ—Å—Å–∏–∏
  async updateSessionTitle(sessionId: string, userId: string, title: string): Promise<void> {
    try {
      await prisma.session.update({
        where: {
          id: sessionId,
          userId // Ensure user owns the session
        },
        data: {
          title: title.trim()
        }
      });

      logger.info('Session title updated', { sessionId, userId, title });
    } catch (error) {
      logger.error('Failed to update session title', { error, sessionId, userId });
      throw new Error('Failed to update session title');
    }
  }

  async getSession(sessionId: string, userId: string) {
    try {
      const session = await prisma.session.findFirst({
        where: {
          id: sessionId,
          userId
        },
        include: {
          messages: {
            include: {
              score: true
            },
            orderBy: {
              index: 'asc'
            }
          }
        }
      });

      if (!session) {
        throw new Error('Session not found');
      }

      // Enhance session object with metadata properties for backward compatibility
      const metadata = (session.metadata as any) || {};
      
      return {
        ...session,
        // ‚úÖ –ù–û–í–û–ï: –ò—Å–ø–æ–ª—å–∑—É–µ–º –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω—ã–µ –ø–æ–ª—è –≥–¥–µ –≤–æ–∑–º–æ–∂–Ω–æ
        projectContext: metadata.projectContext,
        sessionGoal: metadata.sessionGoal,
        completedAt: metadata.completedAt,
        // –ò—Å–ø–æ–ª—å–∑—É–µ–º –Ω–æ–≤—ã–µ –ø–æ–ª—è –≤–º–µ—Å—Ç–æ metadata
        messageCount: session.messageCount,
        overallScore: session.overallScore,
        trend: session.trend,
        dimensionAverages: {
          strategic: session.strategicAvg,
          tactical: session.tacticalAvg,
          cognitive: session.cognitiveAvg,
          innovation: session.innovationAvg
        },
        patterns: metadata.patterns || [],
        insights: metadata.insights || [],
        // Transform messages to include scores array for compatibility
        messages: session.messages.map(msg => ({
          ...msg,
          scores: msg.score ? [msg.score] : []
        }))
      };
    } catch (error) {
      logger.error('Failed to get session', { error, sessionId, userId });
      throw new Error('Failed to get session');
    }
  }

  async getUserSessions(
    userId: string, 
    limit: number = 20, 
    offset: number = 0
  ) {
    try {
      // ‚úÖ –û–ü–¢–ò–ú–ò–ó–ò–†–û–í–ê–ù–û: –ë—ã—Å—Ç—Ä—ã–µ –∑–∞–ø—Ä–æ—Å—ã –ø–æ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω—ã–º –ø–æ–ª—è–º
      const sessions = await prisma.session.findMany({
        where: { userId },
        orderBy: { createdAt: 'desc' },
        take: limit,
        skip: offset,
        select: {
          id: true,
          title: true,
          platform: true,
          status: true,
          createdAt: true,
          updatedAt: true,
          // –ù–æ–≤—ã–µ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω—ã–µ –ø–æ–ª—è
          messageCount: true,
          overallScore: true,
          strategicAvg: true,
          tacticalAvg: true,
          cognitiveAvg: true,
          innovationAvg: true,
          bestScore: true,
          worstScore: true,
          trend: true,
          // Metadata —Ç–æ–ª—å–∫–æ –¥–ª—è –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
          metadata: true
        }
      });

      const total = await prisma.session.count({
        where: { userId }
      });

      // ‚úÖ –ù–û–í–û–ï: –ò—Å–ø–æ–ª—å–∑—É–µ–º –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω—ã–µ –ø–æ–ª—è –Ω–∞–ø—Ä—è–º—É—é
      const transformedSessions = sessions.map(session => {
        const metadata = (session.metadata as any) || {};
        return {
          ...session,
          projectContext: metadata.projectContext,
          sessionGoal: metadata.sessionGoal,
          completedAt: metadata.completedAt,
          // –ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω—ã–µ –ø–æ–ª—è —É–∂–µ –µ—Å—Ç—å –≤ session
          dimensionAverages: {
            strategic: session.strategicAvg,
            tactical: session.tacticalAvg,
            cognitive: session.cognitiveAvg,
            innovation: session.innovationAvg
          }
        };
      });

      return {
        sessions: transformedSessions,
        total,
        hasMore: offset + limit < total
      };
    } catch (error) {
      logger.error('Failed to get user sessions', { error, userId });
      throw new Error('Failed to get user sessions');
    }
  }

  async deleteSession(sessionId: string, userId: string): Promise<void> {
    try {
      await prisma.session.delete({
        where: {
          id: sessionId,
          userId
        }
      });

      // Clean up cache
      await redis.del(`session:${sessionId}:summary`);

      logger.info('Session deleted', { sessionId, userId });
    } catch (error) {
      logger.error('Failed to delete session', { error, sessionId, userId });
      throw new Error('Failed to delete session');
    }
  }

  async getSessionAnalytics(userId: string, days: number = 30) {
    try {
      const since = new Date();
      since.setDate(since.getDate() - days);

      console.log('üìä ANALYTICS: Starting analytics calculation...', {
        userId,
        days,
        since: since.toISOString()
      });

      // ‚úÖ CRITICAL FIX: Include both ACTIVE and COMPLETED sessions for analytics
      const sessions = await prisma.session.findMany({
        where: {
          userId,
          createdAt: {
            gte: since
          },
          // ‚úÖ CRITICAL FIX: Include sessions with analysis data regardless of status
          OR: [
            { status: 'COMPLETED' },
            { 
              status: 'ACTIVE',
              messageCount: { gt: 0 }, // Only include ACTIVE sessions that have been analyzed
              overallScore: { gt: 0 }
            }
          ]
        },
        select: {
          id: true,
          status: true,
          createdAt: true,
          platform: true,
          messageCount: true,
          overallScore: true,
          strategicAvg: true,
          tacticalAvg: true,
          cognitiveAvg: true,
          innovationAvg: true,
          trend: true
        }
      });

      console.log('üìä ANALYTICS: Found sessions for analytics:', {
        totalFound: sessions.length,
        statuses: sessions.reduce((acc, s) => {
          acc[s.status] = (acc[s.status] || 0) + 1;
          return acc;
        }, {} as Record<string, number>),
        sampleSessions: sessions.slice(0, 3).map(s => ({
          id: s.id,
          status: s.status,
          messageCount: s.messageCount,
          overallScore: s.overallScore
        }))
      });

      if (sessions.length === 0) {
        console.log('üìä ANALYTICS: No sessions found, returning zeros');
        return {
          totalSessions: 0,
          totalMessages: 0,
          averageScore: 0,
          improvementRate: 0,
          dimensionAverages: {
            strategic: 0,
            tactical: 0,
            cognitive: 0,
            innovation: 0
          },
          trendDistribution: {},
          platformDistribution: {},
          scoreHistory: []
        };
      }

      // ‚úÖ –ù–û–í–û–ï: –ò—Å–ø–æ–ª—å–∑—É–µ–º –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω—ã–µ –ø–æ–ª—è –¥–ª—è –≤—ã—á–∏—Å–ª–µ–Ω–∏–π
      const totalSessions = sessions.length;
      const totalMessages = sessions.reduce((sum, s) => sum + s.messageCount, 0);
      const averageScore = sessions.reduce((sum, s) => sum + s.overallScore, 0) / totalSessions;

      // Calculate improvement rate (comparing first half vs second half)
      const midpoint = Math.floor(sessions.length / 2);
      const firstHalf = sessions.slice(0, midpoint);
      const secondHalf = sessions.slice(midpoint);
      
      const firstHalfAvg = firstHalf.length > 0 
        ? firstHalf.reduce((sum, s) => sum + s.overallScore, 0) / firstHalf.length 
        : 0;
      const secondHalfAvg = secondHalf.length > 0 
        ? secondHalf.reduce((sum, s) => sum + s.overallScore, 0) / secondHalf.length 
        : 0;
      
      const improvementRate = firstHalfAvg > 0 
        ? ((secondHalfAvg - firstHalfAvg) / firstHalfAvg) * 100 
        : 0;

      // ‚úÖ –û–ü–¢–ò–ú–ò–ó–ò–†–û–í–ê–ù–û: –ü—Ä—è–º—ã–µ –≤—ã—á–∏—Å–ª–µ–Ω–∏—è –∏–∑ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω—ã—Ö –ø–æ–ª–µ–π
      const dimensionAverages = {
        strategic: sessions.reduce((sum, s) => sum + s.strategicAvg, 0) / totalSessions,
        tactical: sessions.reduce((sum, s) => sum + s.tacticalAvg, 0) / totalSessions,
        cognitive: sessions.reduce((sum, s) => sum + s.cognitiveAvg, 0) / totalSessions,
        innovation: sessions.reduce((sum, s) => sum + s.innovationAvg, 0) / totalSessions
      };

      // Trend and platform distributions
      const trendDistribution = sessions.reduce((acc, s) => {
        const trend = s.trend || 'stable';
        acc[trend] = (acc[trend] || 0) + 1;
        return acc;
      }, {} as Record<string, number>);

      const platformDistribution = sessions.reduce((acc, s) => {
        acc[s.platform] = (acc[s.platform] || 0) + 1;
        return acc;
      }, {} as Record<string, number>);

      // Score history (last 30 data points)
      const scoreHistory = sessions
        .slice(-30)
        .map(s => ({
          date: s.createdAt.toISOString().split('T')[0],
          score: s.overallScore
        }));

      const analytics = {
        totalSessions,
        totalMessages,
        averageScore: Math.round(averageScore),
        improvementRate: Math.round(improvementRate),
        dimensionAverages,
        trendDistribution,
        platformDistribution,
        scoreHistory
      };

      console.log('üìä ANALYTICS: Calculated analytics:', {
        totalSessions: analytics.totalSessions,
        totalMessages: analytics.totalMessages,
        averageScore: analytics.averageScore,
        dimensionAverages: analytics.dimensionAverages
      });

      return analytics;
    } catch (error) {
      console.error('‚ùå ANALYTICS: Failed to get session analytics:', {
        error: error instanceof Error ? error.message : String(error),
        userId,
        days
      });
      
      logger.error('Failed to get session analytics', { error, userId });
      throw new Error('Failed to get session analytics');
    }
  }
}