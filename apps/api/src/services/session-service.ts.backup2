import { prisma } from '../lib/prisma';
import { redis } from '../lib/redis';
import { logger } from '../lib/logger';
import { SessionSummary, SessionMetadata, AnalysisPattern, Platform } from '../types';

export class SessionService {
  /**
   * Helper method to normalize platform values to match Prisma enum
   */
  private normalizePlatform(platform?: string): Platform {
    if (!platform) return 'OTHER';
    
    const platformMap: Record<string, Platform> = {
      // Handle lowercase input (from frontend/parser)
      'claude': 'CLAUDE',
      'chatgpt': 'CHATGPT', 
      'other': 'OTHER',
      'auto': 'AUTO',
      // Handle uppercase input (already correct)
      'CLAUDE': 'CLAUDE',
      'CHATGPT': 'CHATGPT',
      'OTHER': 'OTHER',
      'AUTO': 'AUTO'
    };
    
    return platformMap[platform.toLowerCase()] || 'OTHER';
  }

  async createSession(userId: string, metadata: SessionMetadata): Promise<string> {
    try {
      const session = await prisma.session.create({
        data: {
          userId,
          title: metadata.title || `${metadata.platform || 'Analysis'} - ${new Date().toLocaleDateString()}`,
          platform: this.normalizePlatform(metadata.platform),
          
          // ✅ НОВОЕ: Инициализация производительных полей
          messageCount: metadata.messageCount || 0,
          overallScore: metadata.overallScore || 0,
          strategicAvg: metadata.dimensionAverages?.strategic || 0,
          tacticalAvg: metadata.dimensionAverages?.tactical || 0,
          cognitiveAvg: metadata.dimensionAverages?.cognitive || 0,
          innovationAvg: metadata.dimensionAverages?.innovation || 0,
          trend: metadata.trend || 'stable',
          
          // Детальные данные в metadata JSON
          metadata: {
            ...metadata,
            createdAt: new Date().toISOString()
          } as any
        }
      });

      logger.info('Session created', { sessionId: session.id, userId });
      return session.id;
    } catch (error) {
      logger.error('Failed to create session', { error, userId });
      throw new Error('Failed to create session');
    }
  }

  async updateSession(
    userId: string,
    sessionId: string, 
    summary: SessionSummary
  ): Promise<void> {
    try {
      // ✅ НОВОЕ: Обновление производительных полей + metadata
      const updatedData = {
        // Производительные поля для быстрых запросов
        messageCount: summary.messageCount,
        overallScore: summary.overallScore,
        strategicAvg: summary.dimensionAverages.strategic,
        tacticalAvg: summary.dimensionAverages.tactical,
        cognitiveAvg: summary.dimensionAverages.cognitive,
        innovationAvg: summary.dimensionAverages.innovation,
        bestScore: summary.bestScore,
        worstScore: summary.worstScore,
        trend: summary.trend,
        
        // Статус обновляем
        status: 'COMPLETED' as any,
        
        // Детальные данные в metadata
        metadata: {
          messageCount: summary.messageCount,
          overallScore: summary.overallScore,
          bestScore: summary.bestScore,
          worstScore: summary.worstScore,
          trend: summary.trend,
          dimensionAverages: summary.dimensionAverages,
          patterns: summary.patterns,
          insights: summary.insights,
          completedAt: new Date().toISOString(),
          updatedAt: new Date().toISOString()
        } as any
      };

      await prisma.session.update({
        where: { 
          id: sessionId,
          userId // Ensure user owns the session
        },
        data: updatedData
      });

      // Cache session summary for quick access
      await redis.setex(
        `session:${sessionId}:summary`,
        3600, // 1 hour
        JSON.stringify(summary)
      );

      logger.info('Session updated', { sessionId, userId });
    } catch (error) {
      logger.error('Failed to update session', { error, sessionId, userId });
      throw new Error('Failed to update session');
    }
  }

  // ✅ НОВЫЙ МЕТОД: Обновление заголовка сессии
  async updateSessionTitle(sessionId: string, userId: string, title: string): Promise<void> {
    try {
      await prisma.session.update({
        where: {
          id: sessionId,
          userId // Ensure user owns the session
        },
        data: {
          title: title.trim()
        }
      });

      logger.info('Session title updated', { sessionId, userId, title });
    } catch (error) {
      logger.error('Failed to update session title', { error, sessionId, userId });
      throw new Error('Failed to update session title');
    }
  }

  async getSession(sessionId: string, userId: string) {
    try {
      const session = await prisma.session.findFirst({
        where: {
          id: sessionId,
          userId
        },
        include: {
          messages: {
            include: {
              score: true
            },
            orderBy: {
              index: 'asc'
            }
          }
        }
      });

      if (!session) {
        throw new Error('Session not found');
      }

      // Enhance session object with metadata properties for backward compatibility
      const metadata = (session.metadata as any) || {};
      
      return {
        ...session,
        // ✅ НОВОЕ: Используем производительные поля где возможно
        projectContext: metadata.projectContext,
        sessionGoal: metadata.sessionGoal,
        completedAt: metadata.completedAt,
        // Используем новые поля вместо metadata
        messageCount: session.messageCount,
        overallScore: session.overallScore,
        trend: session.trend,
        dimensionAverages: {
          strategic: session.strategicAvg,
          tactical: session.tacticalAvg,
          cognitive: session.cognitiveAvg,
          innovation: session.innovationAvg
        },
        patterns: metadata.patterns || [],
        insights: metadata.insights || [],
        // Transform messages to include scores array for compatibility
        messages: session.messages.map(msg => ({
          ...msg,
          scores: msg.score ? [msg.score] : []
        }))
      };
    } catch (error) {
      logger.error('Failed to get session', { error, sessionId, userId });
      throw new Error('Failed to get session');
    }
  }

  async getUserSessions(
    userId: string, 
    limit: number = 20, 
    offset: number = 0
  ) {
    try {
      // ✅ ОПТИМИЗИРОВАНО: Быстрые запросы по производительным полям
      const sessions = await prisma.session.findMany({
        where: { userId },
        orderBy: { createdAt: 'desc' },
        take: limit,
        skip: offset,
        select: {
          id: true,
          title: true,
          platform: true,
          status: true,
          createdAt: true,
          updatedAt: true,
          // Новые производительные поля
          messageCount: true,
          overallScore: true,
          strategicAvg: true,
          tacticalAvg: true,
          cognitiveAvg: true,
          innovationAvg: true,
          bestScore: true,
          worstScore: true,
          trend: true,
          // Metadata только для дополнительных данных
          metadata: true
        }
      });

      const total = await prisma.session.count({
        where: { userId }
      });

      // ✅ НОВОЕ: Используем производительные поля напрямую
      const transformedSessions = sessions.map(session => {
        const metadata = (session.metadata as any) || {};
        return {
          ...session,
          projectContext: metadata.projectContext,
          sessionGoal: metadata.sessionGoal,
          completedAt: metadata.completedAt,
          // Производительные поля уже есть в session
          dimensionAverages: {
            strategic: session.strategicAvg,
            tactical: session.tacticalAvg,
            cognitive: session.cognitiveAvg,
            innovation: session.innovationAvg
          }
        };
      });

      return {
        sessions: transformedSessions,
        total,
        hasMore: offset + limit < total
      };
    } catch (error) {
      logger.error('Failed to get user sessions', { error, userId });
      throw new Error('Failed to get user sessions');
    }
  }

  async deleteSession(sessionId: string, userId: string): Promise<void> {
    try {
      await prisma.session.delete({
        where: {
          id: sessionId,
          userId
        }
      });

      // Clean up cache
      await redis.del(`session:${sessionId}:summary`);

      logger.info('Session deleted', { sessionId, userId });
    } catch (error) {
      logger.error('Failed to delete session', { error, sessionId, userId });
      throw new Error('Failed to delete session');
    }
  }

  async getSessionAnalytics(userId: string, days: number = 30) {
    try {
      const since = new Date();
      since.setDate(since.getDate() - days);

      // ✅ ОПТИМИЗИРОВАНО: Быстрые запросы по производительным полям
      const sessions = await prisma.session.findMany({
        where: {
          userId,
          createdAt: {
            gte: since
          },
          status: 'COMPLETED'
        },
        select: {
          createdAt: true,
          platform: true,
          messageCount: true,
          overallScore: true,
          strategicAvg: true,
          tacticalAvg: true,
          cognitiveAvg: true,
          innovationAvg: true,
          trend: true
        }
      });

      if (sessions.length === 0) {
        return {
          totalSessions: 0,
          totalMessages: 0,
          averageScore: 0,
          improvementRate: 0,
          dimensionAverages: {
            strategic: 0,
            tactical: 0,
            cognitive: 0,
            innovation: 0
          },
          trendDistribution: {},
          platformDistribution: {},
          scoreHistory: []
        };
      }

      // ✅ НОВОЕ: Используем производительные поля для вычислений
      const totalSessions = sessions.length;
      const totalMessages = sessions.reduce((sum, s) => sum + s.messageCount, 0);
      const averageScore = sessions.reduce((sum, s) => sum + s.overallScore, 0) / totalSessions;

      // Calculate improvement rate (comparing first half vs second half)
      const midpoint = Math.floor(sessions.length / 2);
      const firstHalf = sessions.slice(0, midpoint);
      const secondHalf = sessions.slice(midpoint);
      
      const firstHalfAvg = firstHalf.length > 0 
        ? firstHalf.reduce((sum, s) => sum + s.overallScore, 0) / firstHalf.length 
        : 0;
      const secondHalfAvg = secondHalf.length > 0 
        ? secondHalf.reduce((sum, s) => sum + s.overallScore, 0) / secondHalf.length 
        : 0;
      
      const improvementRate = firstHalfAvg > 0 
        ? ((secondHalfAvg - firstHalfAvg) / firstHalfAvg) * 100 
        : 0;

      // ✅ ОПТИМИЗИРОВАНО: Прямые вычисления из производительных полей
      const dimensionAverages = {
        strategic: sessions.reduce((sum, s) => sum + s.strategicAvg, 0) / totalSessions,
        tactical: sessions.reduce((sum, s) => sum + s.tacticalAvg, 0) / totalSessions,
        cognitive: sessions.reduce((sum, s) => sum + s.cognitiveAvg, 0) / totalSessions,
        innovation: sessions.reduce((sum, s) => sum + s.innovationAvg, 0) / totalSessions
      };

      // Trend and platform distributions
      const trendDistribution = sessions.reduce((acc, s) => {
        const trend = s.trend || 'stable';
        acc[trend] = (acc[trend] || 0) + 1;
        return acc;
      }, {} as Record<string, number>);

      const platformDistribution = sessions.reduce((acc, s) => {
        acc[s.platform] = (acc[s.platform] || 0) + 1;
        return acc;
      }, {} as Record<string, number>);

      // Score history (last 30 data points)
      const scoreHistory = sessions
        .slice(-30)
        .map(s => ({
          date: s.createdAt.toISOString().split('T')[0],
          score: s.overallScore
        }));

      return {
        totalSessions,
        totalMessages,
        averageScore: Math.round(averageScore),
        improvementRate: Math.round(improvementRate),
        dimensionAverages,
        trendDistribution,
        platformDistribution,
        scoreHistory
      };
    } catch (error) {
      logger.error('Failed to get session analytics', { error, userId });
      throw new Error('Failed to get session analytics');
    }
  }
}