import { prisma } from '../lib/prisma';
import { redis } from '../lib/redis';
import { logger } from '../lib/logger';
import { SessionSummary, SessionMetadata, AnalysisPattern, Platform } from '../types';

export class SessionService {
  /**
   * ‚úÖ CRITICAL FIX: Normalize platform values to match unified lowercase Prisma enum
   */
  private normalizePlatform(platform?: string): Platform {
    if (!platform) return 'other';
    
    // ‚úÖ UNIFIED: All platforms mapped to lowercase for database compatibility
    const platformMap: Record<string, Platform> = {
      // Handle lowercase input (from frontend/parser) - direct mapping
      'claude': 'claude',
      'chatgpt': 'chatgpt', 
      'other': 'other',
      'auto': 'auto',
      // Handle legacy uppercase input - convert to lowercase
      'CLAUDE': 'claude',
      'CHATGPT': 'chatgpt',
      'OTHER': 'other',
      'AUTO': 'auto'
    };
    
    // ‚úÖ ENHANCED: Safe conversion with fallback
    const normalizedPlatform = platformMap[platform] || platformMap[platform.toLowerCase()];
    return normalizedPlatform || 'other';
  }

  async createSession(userId: string, userEmail: string, metadata: SessionMetadata): Promise<string> {
    try {
      // ‚úÖ ENHANCED: Auto-create user if not exists with better error handling
      console.log('üë§ ENSURING USER EXISTS:', userId, userEmail);
      
      try {
        await prisma.user.upsert({
          where: { id: userId },
          update: {
            // Update email if changed
            email: userEmail || 'unknown@example.com',
            updatedAt: new Date()
          },
          create: {
            id: userId,
            email: userEmail || 'unknown@example.com',
            name: userEmail?.split('@')[0] || 'Anonymous User',
            tier: 'FREE'
          }
        });
        
        console.log('‚úÖ USER ENSURED:', userId);
      } catch (userError) {
        console.error('‚ùå User upsert failed:', userError);
        logger.error('User upsert failed', { 
          error: userError, 
          userId, 
          userEmail 
        });
        // Continue execution - user might already exist
      }

      // ‚úÖ CRITICAL FIX: Use normalized lowercase platform
      const normalizedPlatform = this.normalizePlatform(metadata.platform);
      console.log('üîÑ PLATFORM NORMALIZED:', metadata.platform, '‚Üí', normalizedPlatform);

      // Create session with unified platform and 5D support
      const session = await prisma.session.create({
        data: {
          userId,
          title: metadata.title || `${normalizedPlatform} Analysis - ${new Date().toLocaleDateString()}`,
          platform: normalizedPlatform, // ‚úÖ UNIFIED: lowercase platform
          
          // ‚úÖ ENHANCED: Initialize 5D performance fields
          messageCount: metadata.messageCount || 0,
          overallScore: metadata.overallScore || 0,
          strategicAvg: metadata.dimensionAverages?.strategic || 0,
          tacticalAvg: metadata.dimensionAverages?.tactical || 0,
          cognitiveAvg: metadata.dimensionAverages?.cognitive || 0,
          innovationAvg: metadata.dimensionAverages?.innovation || 0,
          contextAvg: metadata.dimensionAverages?.context || 0, // ‚úÖ NEW: 5th dimension
          trend: metadata.trend || 'stable',
          
          // ‚úÖ ENHANCED: Parsing metadata support
          parsingMethod: metadata.parsingMethod,
          parsingConfidence: metadata.parsingConfidence,
          parsingCost: metadata.parsingCost,
          
          // Detailed data in metadata JSON
          metadata: {
            ...metadata,
            createdAt: new Date().toISOString()
          } as any
        }
      });

      console.log('‚úÖ SESSION CREATED with 5D support:', session.id, 'Platform:', session.platform);
      logger.info('Session created successfully', { 
        sessionId: session.id, 
        userId,
        userEmail,
        platform: session.platform,
        contextAvg: session.contextAvg // ‚úÖ NEW: Log 5th dimension
      });
      
      return session.id;
    } catch (error) {
      console.error('‚ùå SESSION CREATION FAILED:', error);
      logger.error('Failed to create session', { 
        error, 
        userId, 
        userEmail,
        metadata: metadata.title,
        platform: metadata.platform 
      });
      
      // ‚úÖ ENHANCED: Better error diagnostics
      const errorMessage = error instanceof Error ? error.message : String(error);
      const errorCode = (error as any)?.code;
      
      if (errorMessage.includes('Foreign key constraint')) {
        throw new Error('User synchronization failed. Please refresh and try again.');
      } else if (errorCode === 'P2002') {
        throw new Error('Session already exists');
      } else {
        throw new Error('Failed to create session');
      }
    }
  }

  async updateSession(
    userId: string,
    sessionId: string, 
    summary: SessionSummary
  ): Promise<void> {
    try {
      // ‚úÖ ENHANCED: Update with 5D dimension averages
      const updatedData = {
        // 5D performance fields for fast access
        messageCount: summary.messageCount,
        overallScore: summary.overallScore,
        strategicAvg: summary.dimensionAverages.strategic,
        tacticalAvg: summary.dimensionAverages.tactical,
        cognitiveAvg: summary.dimensionAverages.cognitive,
        innovationAvg: summary.dimensionAverages.innovation,
        contextAvg: summary.dimensionAverages.context, // ‚úÖ NEW: 5th dimension update
        bestScore: summary.bestScore,
        worstScore: summary.worstScore,
        trend: summary.trend,
        
        // ‚úÖ FIXED: Proper status setting without type errors
        status: 'COMPLETED' as const,
        
        // ‚úÖ ENHANCED: 5D metadata with context dimension
        metadata: {
          messageCount: summary.messageCount,
          overallScore: summary.overallScore,
          bestScore: summary.bestScore,
          worstScore: summary.worstScore,
          trend: summary.trend,
          dimensionAverages: summary.dimensionAverages, // ‚úÖ NOW includes context
          patterns: summary.patterns,
          insights: summary.insights,
          completedAt: new Date().toISOString(),
          updatedAt: new Date().toISOString()
        } as any
      };

      const updatedSession = await prisma.session.update({
        where: { 
          id: sessionId,
          userId // Ensure user owns the session
        },
        data: updatedData
      });

      // ‚úÖ ENHANCED: Log 5D update
      console.log('‚úÖ SESSION 5D UPDATE COMPLETE:', {
        sessionId,
        userId,
        status: updatedSession.status,
        messageCount: updatedSession.messageCount,
        overallScore: updatedSession.overallScore,
        contextAvg: updatedSession.contextAvg // ‚úÖ NEW: Log context dimension
      });

      // Cache session summary with 5D data
      await redis.setex(
        `session:${sessionId}:summary`,
        3600, // 1 hour
        JSON.stringify(summary)
      );

      logger.info('Session updated with 5D support', { 
        sessionId, 
        userId, 
        status: updatedSession.status,
        contextAvg: updatedSession.contextAvg // ‚úÖ NEW: Log context dimension
      });
    } catch (error) {
      console.error('‚ùå SESSION 5D UPDATE FAILED:', {
        error: error instanceof Error ? error.message : String(error),
        sessionId,
        userId,
        summaryMessageCount: summary.messageCount,
        summaryScore: summary.overallScore,
        summaryContext: summary.dimensionAverages.context // ‚úÖ NEW: Log context in error
      });
      
      logger.error('Failed to update session', { error, sessionId, userId });
      throw new Error('Failed to update session');
    }
  }

  // ‚úÖ PRESERVED: Update session title method
  async updateSessionTitle(sessionId: string, userId: string, title: string): Promise<void> {
    try {
      await prisma.session.update({
        where: {
          id: sessionId,
          userId // Ensure user owns the session
        },
        data: {
          title: title.trim()
        }
      });

      logger.info('Session title updated', { sessionId, userId, title });
    } catch (error) {
      logger.error('Failed to update session title', { error, sessionId, userId });
      throw new Error('Failed to update session title');
    }
  }

  async getSession(sessionId: string, userId: string) {
    try {
      const session = await prisma.session.findFirst({
        where: {
          id: sessionId,
          userId
        },
        include: {
          messages: {
            include: {
              score: true
            },
            orderBy: {
              index: 'asc'
            }
          }
        }
      });

      if (!session) {
        throw new Error('Session not found');
      }

      // Enhance session object with metadata properties for backward compatibility
      const metadata = (session.metadata as any) || {};
      
      return {
        ...session,
        // ‚úÖ ENHANCED: Use 5D performance fields where possible
        projectContext: metadata.projectContext,
        sessionGoal: metadata.sessionGoal,
        completedAt: metadata.completedAt,
        // Use new 5D fields instead of metadata
        messageCount: session.messageCount,
        overallScore: session.overallScore,
        trend: session.trend,
        dimensionAverages: {
          strategic: session.strategicAvg,
          tactical: session.tacticalAvg,
          cognitive: session.cognitiveAvg,
          innovation: session.innovationAvg,
          context: session.contextAvg // ‚úÖ NEW: 5th dimension in response
        },
        patterns: metadata.patterns || [],
        insights: metadata.insights || [],
        // Transform messages to include scores array for compatibility
        messages: session.messages.map(msg => ({
          ...msg,
          scores: msg.score ? [msg.score] : []
        }))
      };
    } catch (error) {
      logger.error('Failed to get session', { error, sessionId, userId });
      throw new Error('Failed to get session');
    }
  }

  async getUserSessions(
    userId: string, 
    limit: number = 20, 
    offset: number = 0
  ) {
    try {
      // ‚úÖ OPTIMIZED: Fast queries using 5D performance fields
      const sessions = await prisma.session.findMany({
        where: { userId },
        orderBy: { createdAt: 'desc' },
        take: limit,
        skip: offset,
        select: {
          id: true,
          title: true,
          platform: true,
          status: true,
          createdAt: true,
          updatedAt: true,
          // ‚úÖ ENHANCED: 5D performance fields
          messageCount: true,
          overallScore: true,
          strategicAvg: true,
          tacticalAvg: true,
          cognitiveAvg: true,
          innovationAvg: true,
          contextAvg: true, // ‚úÖ NEW: 5th dimension in list
          bestScore: true,
          worstScore: true,
          trend: true,
          // Enhanced parsing fields
          parsingMethod: true,
          parsingConfidence: true,
          parsingCost: true,
          // Metadata only for additional data
          metadata: true
        }
      });

      const total = await prisma.session.count({
        where: { userId }
      });

      // ‚úÖ ENHANCED: Use 5D performance fields directly
      const transformedSessions = sessions.map(session => {
        const metadata = (session.metadata as any) || {};
        return {
          ...session,
          projectContext: metadata.projectContext,
          sessionGoal: metadata.sessionGoal,
          completedAt: metadata.completedAt,
          // ‚úÖ ENHANCED: 5D dimension averages from performance fields
          dimensionAverages: {
            strategic: session.strategicAvg,
            tactical: session.tacticalAvg,
            cognitive: session.cognitiveAvg,
            innovation: session.innovationAvg,
            context: session.contextAvg // ‚úÖ NEW: 5th dimension in session list
          }
        };
      });

      return {
        sessions: transformedSessions,
        total,
        hasMore: offset + limit < total
      };
    } catch (error) {
      logger.error('Failed to get user sessions', { error, userId });
      throw new Error('Failed to get user sessions');
    }
  }

  async deleteSession(sessionId: string, userId: string): Promise<void> {
    try {
      await prisma.session.delete({
        where: {
          id: sessionId,
          userId
        }
      });

      // Clean up cache
      await redis.del(`session:${sessionId}:summary`);

      logger.info('Session deleted', { sessionId, userId });
    } catch (error) {
      logger.error('Failed to delete session', { error, sessionId, userId });
      throw new Error('Failed to delete session');
    }
  }

  async getSessionAnalytics(userId: string, days: number = 30) {
    try {
      const since = new Date();
      since.setDate(since.getDate() - days);

      console.log('üìä 5D ANALYTICS: Starting enhanced analytics calculation...', {
        userId,
        days,
        since: since.toISOString()
      });

      // ‚úÖ ENHANCED: Include both ACTIVE and COMPLETED sessions for 5D analytics
      const sessions = await prisma.session.findMany({
        where: {
          userId,
          createdAt: {
            gte: since
          },
          // ‚úÖ ENHANCED: Include sessions with 5D analysis data
          OR: [
            { status: 'COMPLETED' },
            { 
              status: 'ACTIVE',
              messageCount: { gt: 0 },
              overallScore: { gt: 0 }
            }
          ]
        },
        select: {
          id: true,
          status: true,
          createdAt: true,
          platform: true,
          messageCount: true,
          overallScore: true,
          strategicAvg: true,
          tacticalAvg: true,
          cognitiveAvg: true,
          innovationAvg: true,
          contextAvg: true, // ‚úÖ NEW: 5th dimension in analytics
          trend: true
        }
      });

      console.log('üìä 5D ANALYTICS: Found sessions for enhanced analytics:', {
        totalFound: sessions.length,
        statuses: sessions.reduce((acc, s) => {
          acc[s.status] = (acc[s.status] || 0) + 1;
          return acc;
        }, {} as Record<string, number>),
        avg5DScores: sessions.length > 0 ? {
          context: sessions.reduce((sum, s) => sum + s.contextAvg, 0) / sessions.length,
          strategic: sessions.reduce((sum, s) => sum + s.strategicAvg, 0) / sessions.length
        } : null
      });

      if (sessions.length === 0) {
        console.log('üìä 5D ANALYTICS: No sessions found, returning 5D zeros');
        return {
          totalSessions: 0,
          totalMessages: 0,
          averageScore: 0,
          improvementRate: 0,
          dimensionAverages: {
            strategic: 0,
            tactical: 0,
            cognitive: 0,
            innovation: 0,
            context: 0 // ‚úÖ NEW: 5th dimension in analytics response
          },
          trendDistribution: {},
          platformDistribution: {},
          scoreHistory: []
        };
      }

      // ‚úÖ ENHANCED: Use 5D performance fields for calculations
      const totalSessions = sessions.length;
      const totalMessages = sessions.reduce((sum, s) => sum + s.messageCount, 0);
      const averageScore = sessions.reduce((sum, s) => sum + s.overallScore, 0) / totalSessions;

      // Calculate improvement rate (comparing first half vs second half)
      const midpoint = Math.floor(sessions.length / 2);
      const firstHalf = sessions.slice(0, midpoint);
      const secondHalf = sessions.slice(midpoint);
      
      const firstHalfAvg = firstHalf.length > 0 
        ? firstHalf.reduce((sum, s) => sum + s.overallScore, 0) / firstHalf.length 
        : 0;
      const secondHalfAvg = secondHalf.length > 0 
        ? secondHalf.reduce((sum, s) => sum + s.overallScore, 0) / secondHalf.length 
        : 0;
      
      const improvementRate = firstHalfAvg > 0 
        ? ((secondHalfAvg - firstHalfAvg) / firstHalfAvg) * 100 
        : 0;

      // ‚úÖ ENHANCED: 5D dimension averages from performance fields
      const dimensionAverages = {
        strategic: sessions.reduce((sum, s) => sum + s.strategicAvg, 0) / totalSessions,
        tactical: sessions.reduce((sum, s) => sum + s.tacticalAvg, 0) / totalSessions,
        cognitive: sessions.reduce((sum, s) => sum + s.cognitiveAvg, 0) / totalSessions,
        innovation: sessions.reduce((sum, s) => sum + s.innovationAvg, 0) / totalSessions,
        context: sessions.reduce((sum, s) => sum + s.contextAvg, 0) / totalSessions // ‚úÖ NEW: 5th dimension average
      };

      // Trend and platform distributions
      const trendDistribution = sessions.reduce((acc, s) => {
        const trend = s.trend || 'stable';
        acc[trend] = (acc[trend] || 0) + 1;
        return acc;
      }, {} as Record<string, number>);

      const platformDistribution = sessions.reduce((acc, s) => {
        acc[s.platform] = (acc[s.platform] || 0) + 1;
        return acc;
      }, {} as Record<string, number>);

      // Score history (last 30 data points)
      const scoreHistory = sessions
        .slice(-30)
        .map(s => ({
          date: s.createdAt.toISOString().split('T')[0],
          score: s.overallScore
        }));

      const analytics = {
        totalSessions,
        totalMessages,
        averageScore: Math.round(averageScore),
        improvementRate: Math.round(improvementRate),
        dimensionAverages, // ‚úÖ NOW includes context dimension
        trendDistribution,
        platformDistribution,
        scoreHistory
      };

      console.log('üìä 5D ANALYTICS: Calculated enhanced analytics:', {
        totalSessions: analytics.totalSessions,
        totalMessages: analytics.totalMessages,
        averageScore: analytics.averageScore,
        contextAvg: analytics.dimensionAverages.context, // ‚úÖ NEW: Log context average
        allDimensionAverages: analytics.dimensionAverages
      });

      return analytics;
    } catch (error) {
      console.error('‚ùå 5D ANALYTICS: Failed to get enhanced session analytics:', {
        error: error instanceof Error ? error.message : String(error),
        userId,
        days
      });
      
      logger.error('Failed to get session analytics', { error, userId });
      throw new Error('Failed to get session analytics');
    }
  }
}