// ‚úÖ UNIFIED CONVERSATION PARSER with Fixed Metadata Types & 5D Foundation
// apps/api/src/lib/conversation-parser.ts

import { Message, Platform, ParseResult } from '../types';
import { logger } from './logger';

// ‚úÖ ENHANCED: ParseResult options with unified types
export interface EnhancedParseOptions {
  forceHaiku?: boolean;
  userSignature?: string;
  expectedPlatform?: Platform;
  analysisDepth?: 'quick' | 'standard' | 'deep';
  userId?: string;
  requestId?: string;
}

export class ConversationParser {
  
  /**
   * ‚úÖ ENHANCED: Auto-detect platform and parse conversation with unified types
   */
  static parseConversation(text: string, options?: EnhancedParseOptions): ParseResult {
    const startTime = Date.now();
    
    try {
      const detectedPlatform = this.detectPlatform(text);
      
      let result: ParseResult;
      
      switch (detectedPlatform) {
        case 'claude':
          result = this.parseClaudeConversation(text);
          break;
        case 'chatgpt':
          result = this.parseChatGPTConversation(text);
          break;
        default:
          result = this.parseGenericConversation(text);
      }
      
      // ‚úÖ CRITICAL FIX: Only use properties that exist in ParseResult metadata type
      result.metadata = {
        originalLength: text.length,
        processingTime: Date.now() - startTime,
        // ‚úÖ REMOVED: 'method' and 'requestedMethod' (don't exist in types)
        // ‚úÖ ADDED: Valid optional properties from ParseResult metadata
        ...(options?.forceHaiku && { 
          cost: 0, // Estimated cost for future Haiku integration
          patternLearning: ['Enhanced parsing requested'] 
        })
      };
      
      // ‚úÖ FOUNDATION: Set method on result level (exists in ParseResult)
      result.method = 'pattern'; // Current method, will be enhanced later
      
      // ‚úÖ FOUNDATION: Prepare for enhanced parsing integration
      if (options?.forceHaiku) {
        logger.info('Haiku parsing requested but not yet implemented, using pattern parsing');
        // ‚úÖ FIXED: Store in patternLearning instead of non-existent property
        if (!result.metadata.patternLearning) {
          result.metadata.patternLearning = [];
        }
        result.metadata.patternLearning.push('Haiku method requested');
      }
      
      return result;
      
    } catch (error) {
      logger.error('Conversation parsing failed:', error);
      return this.createFallbackResult(text);
    }
  }
  
  /**
   * ‚úÖ UNIFIED: Detect conversation platform with lowercase types
   */
  static detectPlatform(text: string): Platform {
    console.log('üîç DETECTING PLATFORM for text length:', text.length);
    
    let claudeScore = 0;
    let chatgptScore = 0;
    
    try {
      // Claude patterns - safe counting
      const humanMatches = text.match(/Human:/gi);
      if (humanMatches) claudeScore += humanMatches.length;
      
      const assistantMatches = text.match(/Assistant:/gi);
      if (assistantMatches) claudeScore += assistantMatches.length;
      
      const claudeMatches = text.match(/Claude:/gi);
      if (claudeMatches) claudeScore += claudeMatches.length;
      
      // ChatGPT patterns - safe counting
      const userMatches = text.match(/User:/gi);
      if (userMatches) chatgptScore += userMatches.length;
      
      const chatgptMatches = text.match(/ChatGPT:/gi);
      if (chatgptMatches) chatgptScore += chatgptMatches.length;
      
    } catch (error) {
      console.log('Pattern matching error, defaulting to other');
      return 'other';
    }
    
    console.log(`üìä PLATFORM SCORES: Claude=${claudeScore}, ChatGPT=${chatgptScore}`);
    
    // ‚úÖ UNIFIED: Return lowercase platform types
    if (claudeScore > chatgptScore && claudeScore > 0) return 'claude';
    if (chatgptScore > claudeScore && chatgptScore > 0) return 'chatgpt';
    
    return 'other';
  }
  
  /**
   * ‚úÖ ENHANCED: Parse Claude conversation with unified platform type
   */
  static parseClaudeConversation(text: string): ParseResult {
    console.log('ü§ñ PARSING CLAUDE CONVERSATION...');
    
    const messages: Message[] = [];
    let confidence = 0.8;
    let parsedParts = 0;
    
    try {
      // Normalize line endings and clean up
      const cleanText = text
        .replace(/\r\n/g, '\n')
        .replace(/\r/g, '\n')
        .trim();
      
      // Split by role markers
      const textParts = cleanText.split(/(?=\n(?:Human|Assistant):\s*)/i);
      parsedParts = textParts.length;
      
      console.log(`üìù INITIAL SPLIT: ${textParts.length} parts`);
      
      // Process each part
      for (let i = 0; i < textParts.length; i++) {
        const part = textParts[i]?.trim() || '';
        if (!part) continue;
        
        console.log(`üîç PROCESSING PART ${i}: "${part.substring(0, 50)}..."`);
        
        let role: 'user' | 'assistant' | null = null;
        let content = '';
        
        try {
          if (/^Human:\s*/i.test(part)) {
            role = 'user';
            content = part.replace(/^Human:\s*/i, '').trim();
            console.log(`üë§ FOUND USER MESSAGE: ${content.length} chars`);
          } else if (/^Assistant:\s*/i.test(part)) {
            role = 'assistant';
            content = part.replace(/^Assistant:\s*/i, '').trim();
            console.log(`ü§ñ FOUND ASSISTANT MESSAGE: ${content.length} chars`);
          } else {
            console.log(`‚ùì UNCLEAR ROLE for part: "${part.substring(0, 100)}"`);
            
            // If it's the first part and no role markers, assume it's user
            if (i === 0 && textParts.length > 1) {
              role = 'user';
              content = part.trim();
              console.log(`üë§ ASSUMED USER (first part): ${content.length} chars`);
            } else if (messages.length > 0) {
              // Append to previous message if it exists
              const lastMessage = messages[messages.length - 1];
              if (lastMessage && part.length > 10) {
                lastMessage.content += '\n\n' + part;
                console.log(`üìé APPENDED TO PREVIOUS MESSAGE: ${lastMessage.role}`);
                continue;
              }
            }
            
            // Skip if we can't determine role and content is too short
            if (!role && content.length < 20) {
              console.log(`‚è≠Ô∏è SKIPPING SHORT UNCLEAR PART: "${part}"`);
              continue;
            }
          }
        } catch (roleError) {
          console.log('Role parsing error, skipping part');
          continue;
        }
        
        // Add message if we have valid content
        if (role && content && content.length > 5) {
          messages.push({
            role,
            content: content.trim(),
            index: messages.length,
            timestamp: new Date().toISOString()
          });
          console.log(`‚úÖ ADDED ${role.toUpperCase()} MESSAGE #${messages.length}: ${content.length} chars`);
        }
      }
      
      // Validate alternating pattern
      let hasProperAlternation = true;
      for (let i = 1; i < messages.length; i++) {
        if (messages[i]?.role === messages[i-1]?.role) {
          console.log(`‚ö†Ô∏è NON-ALTERNATING PATTERN at index ${i}: ${messages[i-1]?.role} ‚Üí ${messages[i]?.role}`);
          hasProperAlternation = false;
        }
      }
      
      if (!hasProperAlternation) {
        confidence -= 0.2;
      }
      
    } catch (parseError) {
      console.log('Claude parsing error, creating fallback message');
      // Ensure we have at least one message
      if (messages.length === 0) {
        messages.push({
          role: 'user',
          content: text.substring(0, 1000),
          index: 0,
          timestamp: new Date().toISOString()
        });
      }
      confidence = 0.1;
      parsedParts = 1;
    }
    
    console.log(`üìä CLAUDE PARSING COMPLETE: ${messages.length} messages extracted`);
    
    return {
      messages,
      platform: 'claude', // ‚úÖ UNIFIED: lowercase platform
      confidence: Math.max(0.1, confidence),
      method: 'pattern', // ‚úÖ VALID: exists in ParseResult
      metadata: {
        originalLength: text.length,
        processingTime: 0, // Will be set by parent function
        // ‚úÖ FIXED: Use valid metadata properties
        patternLearning: [
          `Claude parsing: ${parsedParts} parts processed`,
          `Final messages: ${messages.length}`,
          `Confidence: ${confidence}`,
          'Method: claude_role_markers'
        ]
      }
    };
  }
  
  /**
   * ‚úÖ ENHANCED: Parse ChatGPT conversation with unified platform type
   */
  static parseChatGPTConversation(text: string): ParseResult {
    console.log('üí¨ PARSING CHATGPT CONVERSATION...');
    
    const messages: Message[] = [];
    let confidence = 0.8;
    let parseMethod = '';
    
    try {
      const cleanText = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n').trim();
      
      let textParts: string[] = [];
      
      // Try different ChatGPT formats
      if (/(?:User|ChatGPT|Assistant):\s*/i.test(cleanText)) {
        textParts = cleanText.split(/(?=\n(?:User|ChatGPT|Assistant):\s*)/i);
        parseMethod = 'chatgpt_role_markers';
      } else if (/\*\*(?:User|Assistant)\*\*/i.test(cleanText)) {
        textParts = cleanText.split(/(?=\n\*\*(?:User|Assistant)\*\*)/i);
        parseMethod = 'chatgpt_bold_markers';
      } else {
        textParts = cleanText.split(/\n\s*\n/).filter(p => p && p.trim());
        parseMethod = 'chatgpt_alternating';
        confidence = 0.4;
      }
      
      console.log(`üìù USING ${parseMethod}: ${textParts.length} parts`);
      
      for (let i = 0; i < textParts.length; i++) {
        const part = textParts[i]?.trim() || '';
        if (!part) continue;
        
        let role: 'user' | 'assistant';
        let content: string;
        
        try {
          if (/^(?:User:|\*\*User\*\*)/i.test(part)) {
            role = 'user';
            content = part.replace(/^(?:User:|\*\*User\*\*)\s*/i, '').trim();
          } else if (/^(?:ChatGPT:|Assistant:|\*\*Assistant\*\*)/i.test(part)) {
            role = 'assistant';
            content = part.replace(/^(?:ChatGPT:|Assistant:|\*\*Assistant\*\*)\s*/i, '').trim();
          } else {
            role = i % 2 === 0 ? 'user' : 'assistant';
            content = part.trim();
            confidence -= 0.1;
          }
          
          if (content && content.length > 5) {
            messages.push({
              role,
              content,
              index: messages.length,
              timestamp: new Date().toISOString()
            });
          }
        } catch (partError) {
          console.log('Part processing error, skipping');
          continue;
        }
      }
      
    } catch (chatgptError) {
      console.log('ChatGPT parsing error, using fallback');
      if (messages.length === 0) {
        messages.push({
          role: 'user',
          content: text.substring(0, 1000),
          index: 0,
          timestamp: new Date().toISOString()
        });
      }
      confidence = 0.1;
      parseMethod = 'fallback';
    }
    
    console.log(`üìä CHATGPT PARSING COMPLETE: ${messages.length} messages extracted`);
    
    return {
      messages,
      platform: 'chatgpt', // ‚úÖ UNIFIED: lowercase platform
      confidence: Math.max(0.1, confidence),
      method: 'pattern', // ‚úÖ VALID: exists in ParseResult
      metadata: {
        originalLength: text.length,
        processingTime: 0, // Will be set by parent function
        // ‚úÖ FIXED: Use valid metadata properties
        patternLearning: [
          `ChatGPT parsing: ${parseMethod}`,
          `Messages extracted: ${messages.length}`,
          `Confidence: ${confidence}`
        ]
      }
    };
  }
  
  /**
   * ‚úÖ ENHANCED: Parse generic conversation with unified platform type
   */
  static parseGenericConversation(text: string): ParseResult {
    console.log('üîÄ PARSING GENERIC CONVERSATION...');
    
    const messages: Message[] = [];
    
    try {
      const cleanText = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n').trim();
      const textParts = cleanText.split(/\n\s*\n/).filter(p => p && p.trim());
      
      console.log(`üìù GENERIC SPLIT: ${textParts.length} parts`);
      
      for (let i = 0; i < textParts.length; i++) {
        const content = textParts[i]?.trim() || '';
        if (!content || content.length < 10) continue;
        
        const role = i % 2 === 0 ? 'user' : 'assistant';
        
        messages.push({
          role,
          content,
          index: messages.length,
          timestamp: new Date().toISOString()
        });
      }
      
    } catch (genericError) {
      console.log('Generic parsing error, creating single message');
      messages.push({
        role: 'user',
        content: text.substring(0, 1000),
        index: 0,
        timestamp: new Date().toISOString()
      });
    }
    
    console.log(`üìä GENERIC PARSING COMPLETE: ${messages.length} messages extracted`);
    
    return {
      messages,
      platform: 'other', // ‚úÖ UNIFIED: lowercase platform
      confidence: 0.3,
      method: 'pattern', // ‚úÖ VALID: exists in ParseResult
      metadata: {
        originalLength: text.length,
        processingTime: 0, // Will be set by parent function
        // ‚úÖ FIXED: Use valid metadata properties
        patternLearning: [
          'Generic alternating parsing',
          `Messages: ${messages.length}`,
          'Low confidence due to no role markers'
        ]
      }
    };
  }
  
  /**
   * ‚úÖ ENHANCED: Create fallback result with unified types
   */
  static createFallbackResult(text: string): ParseResult {
    return {
      messages: [{
        role: 'user',
        content: text.substring(0, 1000),
        index: 0,
        timestamp: new Date().toISOString()
      }],
      platform: 'other', // ‚úÖ UNIFIED: lowercase platform
      confidence: 0.1,
      method: 'pattern', // ‚úÖ VALID: exists in ParseResult
      metadata: {
        originalLength: text.length,
        processingTime: 0,
        // ‚úÖ FIXED: Use valid metadata properties
        patternLearning: ['Fallback parsing applied']
      }
    };
  }
  
  // ‚úÖ ENHANCED: User signature detection for improved parsing
  static detectUserSignature(text: string): string[] {
    const signatures: string[] = [];
    
    // Common signature patterns
    const patterns = [
      /^([A-Z][a-z]+):\s*/gm,        // "Alex:", "John:", etc.
      /^([A-Z]{2,}):\s*/gm,          // "MY:", "JD:", etc.
      /^([a-z_]+\d*):\s*/gm,         // "user1:", "alex_m:", etc.
    ];
    
    patterns.forEach(pattern => {
      const matches = text.match(pattern);
      if (matches) {
        matches.forEach(match => {
          const signature = match.replace(':', '').trim();
          if (!signatures.includes(signature)) {
            signatures.push(signature);
          }
        });
      }
    });
    
    return signatures;
  }
  
  // ‚úÖ FOUNDATION: Enhanced parsing methods with fixed metadata
  static async parseConversationEnhanced(
    text: string, 
    options?: EnhancedParseOptions
  ): Promise<ParseResult> {
    console.log('üöÄ ENHANCED PARSING: Starting enhanced conversation parsing...');
    
    // ‚úÖ FOUNDATION: For now, use existing parsing but log enhanced options
    if (options?.forceHaiku) {
      logger.info('Enhanced parsing with Haiku requested - using pattern parsing for now');
    }
    
    if (options?.userSignature) {
      logger.info(`User signature provided: ${options.userSignature}`);
    }
    
    // Detect user signatures for improved parsing
    const detectedSignatures = this.detectUserSignature(text);
    if (detectedSignatures.length > 0) {
      logger.info(`Detected user signatures: ${detectedSignatures.join(', ')}`);
    }
    
    // Use existing parsing for now
    const result = this.parseConversation(text, options);
    
    // ‚úÖ ENHANCED: Add detected patterns to metadata using valid properties
    if (detectedSignatures.length > 0) {
      if (!result.metadata.patternLearning) {
        result.metadata.patternLearning = [];
      }
      result.metadata.patternLearning.push(
        ...detectedSignatures.map(sig => `Detected signature: ${sig}`)
      );
    }
    
    return result;
  }
  
  // ‚úÖ FOUNDATION: Validation for enhanced parsing
  static validateParseResult(result: ParseResult): boolean {
    if (!result.messages || result.messages.length === 0) {
      return false;
    }
    
    // Check for alternating roles (good conversation pattern)
    for (let i = 1; i < result.messages.length; i++) {
      if (result.messages[i].role === result.messages[i-1].role) {
        logger.warn(`Non-alternating pattern detected at index ${i}`);
      }
    }
    
    // Check for minimum content length
    const shortMessages = result.messages.filter(m => m.content.length < 10);
    if (shortMessages.length > 0) {
      logger.warn(`${shortMessages.length} messages have very short content`);
    }
    
    return true;
  }
}

// ‚úÖ ENHANCED: Function-based export with unified types
export function parseConversation(
  messages: any,
  platform: string = 'auto'
): Message[] {
  console.log('üîÑ PARSE CONVERSATION CALLED:', { 
    inputType: Array.isArray(messages) ? 'array' : typeof messages,
    platform,
    length: Array.isArray(messages) ? messages.length : (typeof messages === 'string' ? messages.length : 'unknown')
  });
  
  try {
    // Handle array of messages
    if (Array.isArray(messages)) {
      console.log('üìã PROCESSING ARRAY INPUT:', messages.length, 'messages');
      return messages.map((msg, index) => ({
        role: msg?.role || 'user',
        content: String(msg?.content || ''),
        index,
        timestamp: msg?.timestamp || new Date().toISOString()
      }));
    }
    
    // Handle text parsing
    const text = typeof messages === 'string' ? messages : String(messages || '');
    if (!text) {
      console.error('‚ùå NO TEXT PROVIDED FOR PARSING');
      return [];
    }
    
    console.log('üìÑ PROCESSING TEXT INPUT:', text.length, 'characters');
    const result = ConversationParser.parseConversation(text);
    
    console.log('‚úÖ PARSING RESULT:', {
      platform: result.platform,
      messageCount: result.messages.length,
      confidence: result.confidence
    });
    
    return result.messages;
    
  } catch (parseError) {
    console.log('Parse conversation error, returning empty array');
    return [];
  }
}

// ‚úÖ ENHANCED: Enhanced parsing function export
export async function parseConversationEnhanced(
  text: string,
  options?: EnhancedParseOptions
): Promise<ParseResult> {
  return ConversationParser.parseConversationEnhanced(text, options);
}

export default ConversationParser;